
1）内存及内存释放
内存：栈内存和堆内存
栈内存：全局作用域 和 私有作用域
       作用：提供了一个供JS代码执行的环境，放的数据主要是基本数据类型
堆内存：放引用数据类型的数据；
       对象数据类型：堆内存中放的是属性名和属性值
       函数数据类型：堆内存中放代码字符串；
内存释放：
    堆内存的释放和栈内存的释放
    堆内存的释放：变量名=null;
    栈内存的释放：
        全局作用域释放：关闭页面 or 关闭浏览器
        私有作用域的释放：私有作用域，当函数执行完成的时候，一般情况默认释放；
        主要有两种情况不释放：
            1）不释放：当函数体中东西，被外面的变量或其他东西占用的时候，不释放；
            2）不立即释放：当函数执行完成时候，会返回一个函数，这个函数还需要再次被调用；
2）++i 和 i++;
    ++i:先自增，再运算；自增后结果参与了运算；
    i++:先运算，再自增；自增后的结果不参与运算；
3) 预解释无节操； 5点
    1)只对等号左边带var的声明，但不定义；
    2）自执行函数不会进行预解释，只有执行到他的时候，声明+定义+调用同步完成
    3）已经声明过的变量，不会进行重复声明
    4)return 后面的语句，不会进行预解释，return下面的语句虽然不执行，但会进行预解释
    5）条件判断语句，无论条件是否成立，都会进行预解释；
        注意：不要在条件判断语句中，写函数的定义阶段
4）this指向问题：3点；
    1）当元素身上的事件被触发的时候，会执行一个函数；函数中的this指向当前这个元素；
    2）当函数被调用的时候，看前面是否有点，点前面是谁，this就谁；
    3）自执行函数中的this，永远都是window；
5）面试题第一题+抽查以上所有题，都画图做一遍
第一题
    f=function(){return true};
    g=function(){return false};
    (function(){
        if(g()&&[]==![]){
            f=function(){return false;}
            function g  (){return true;}
        }
    })();
    alert(f());
    alert(g());
第二题
    var a=12;
    function show(){
        alert(a);
        a=15;
    }
    show();alert(a);
第三题
    function fn() {
            var i = 10;
            return function (n) {
                console.log(n + (++i));
            }
        }
        var f = fn();
        f(15);
        f(20);
        fn()(15);
        fn()(20);
        fn()(30);
        f(30);
6) 添加远程通道 删除远程通道；更新老师讲义；
7）点击按钮弹出对应索引-闭包思想；
。。。。。。。。。。。。。。。。。。。。。。。。。。。
1）关于函数的几种写法：
    1）var f=function (){alert(1)}
    2)f=function (){alert(1)}
    3)function f(){alert(1)}
    f();当f被调用的时候，以上三种的调用结果一样；不同的就是他们预解释不同；
2）.和attribute的区别：
    区别主要有两点：
    1）获取的时候：标签上如果设置了自定义属性，我们通过.拿不到自定义属性的值，但是通过obj.getAttribute()可以拿到；
    2）设置的时候：通过点设置的自定义属性，在标签上看不到，但是通过setAttribute设置的值，在标签上可以看到；
    注意事项：.和attribute不要混合使用；
    。。。。。。。。。。。。。。。。。。。。。。。。。。。
    作业：
    1）把发的第一周的测试题：写完
    2）把预解释的题自己查缺补漏；
    3）整理笔记；











