{}1.封装：对于功能相同代码，我们只需要封装一次，以后再遇到类似的功能，只需要调用即可，无需再重写；避免大量冗余代码；
2.对象的特征：属性和方法；
3.面向对象的特点：
    1.封装：低耦合高内聚；
    2.继承：子类可以继承父类的属性和方法；
    3.多态：多种形态；主要包含重载和重写；
    重载：JS中没有严格意义上的重载，但是他有类似重载的功能，就是传不同的不同的参数，可以实现不同的功能；
    重写：子类可以重写父类的属性和方法；
4.单例模式的优缺点：
单例模式的本质：对象；
优点：
    1）实现模块化开发，而且，他是最简单的模块化开发；
        1.不同模块之间的相互调用：对象名.属性名；
        2.本模块之间的相互调用：this.属性名；
    2）避免了全局变量名的冲突
    注意事项：引入各个模块，需要注意引入顺序，引入顺序是按照各模块之间的相互依赖进行前后排列的；
缺点：不同的对象下，会有很多功能相同的代码，最终造成大量冗余代码
解决措施：工厂模式；

5.模块化开发：
    对于一个大型项目，项目组会分配给不同的工程师进行同步开发，等所有的工程师都开发完成的时候，进行最后的项目合并；
6.类数组：1）arguments 2）元素集合
7.工厂模式：
工厂模式的本质：就普通函数的封装；
工厂模式总共3步骤：
1）引进原材料  ---   创建一个空对象
2）加工原材料  ---   加工对象：给对象添加属性和方法；
3）输出产品    ---   返回对象：return 对象；
工厂模式的优缺点：
优点：避免了单例模式中的大量冗余代码，进行系统的封装
缺点：跟系统内置类的调用方式不同：

8.工厂模式和构造函数模式的区别：
    1）在调用的时候不同：
        工厂模式：调用的时候，只是普通函数的调用createPerson();
        构造函数模式：new CreatePerson();
    2)在函数体内不同：
        工厂模式有三步：1）创建对象 2）加工对象 3）返回对象；
        构造函数模式只有1步： 只有加工对象； 因为系统默认会为其创建对象和返回对象；
9.构造函数：可以创建一个自定义的类，并且可以new出实例；
构造函数主要是：实例和类打交道；
10.构造函数需要注意的细节：
    1）构造函数中的this都是new出来的实例；
    2）构造函数中存放的都是私有的属性和方法
    3）构造函数中系统默认为我们返回一个对象this，不建议自己手动返回，如果非要自己手动返回：
        1.手动返回的是字符串类型：对以前实例上的属性和方法没有影响；
        2.手动返回的是引用数据类型:以前实例身上的属性和方法就被覆盖了；实例无法调用属性和方法；
    4）构造函数在调用的时候，如果没有参数，小括号可以省略；
    5）构造函数就是类和实例在打交道；
    6) 构造函数中带var跟实例没有任何关系，实例只跟this.xxx有关；
构造函数的缺点：构造函数的方法都是私有方法，这个每个实例调用的都是自己私有的方法；
解决措施：原型prototype；
11.原型模式：
原型模式主要是：类 实例 和 原型；
12.原型模式的基础知识：（非常非常重要）
    1）每个函数数据类型（普通函数，类）上，都有一个属性，叫prototype，他是一个对象；
    2）prototype这个对象上，天生自带一个属性，叫constructor:指向当前这个类；
    3）每个对象数据类型（普通对象，prototype，实例）上都有一个属性，叫做__proto__:指向当前实例所属类的原型；
13.Object.prototype上面的属性和方法；
hasOwnProperty：判断是否为私有属性
isPrototypeOf： obj.isPrototypeOf(f1)->判断前一个对象是否在后一个对象的原型链上；
propertyIsEnumerable

14.条件反射：
    1）构造函数：构造函数中的属性和方法都是私有的；
    2）构造函数中的this都是实例；
    3）prototype上的属性和方法都是公有的；
    4）构造函数模式：实例和类；
    5）原型模式：实例 类  原型；
    6）__proto__:原型链；
    7)当我们给 类.prototype={} 这样赋值的时候，constructor指向一定会出问题；

15.原型链：如果想查找 对象.属性名 f1.x：
1）先在自己的私有空间中进行查找，找到的话，说明x是私有属性；
2）找不到：通过__proto__去当前实例所属类的原型上进行查找，找到的话，说明是公有属性；
3）找不到：继续通过__proto__去当前实例所属类的原型上进行查找，找不到，继续通过__proto__一直找到Object.prototype上还没有的话，undefined！；

16：instanceOf： 检测实例是否属于某个类；
17.IE下禁止使用__proto__;
18.学习原型链模式的好处:
1)了解系统提供的类的构成；
2）可以提供更多的学习，比如，ary.keys 不知道，可以通过查询来扩充自己的知识范围；
3）可以给系统内置类上扩充更多的方法，遍历团队里的合作开发者；
。。。。。。。。。。。。。。。。。。。。。。。。。。。。
作业：
1）把图画熟练+3句话--会考察
2）把白天的知识复习巩固
3）把题做完；
4）笔记一定要每天看










