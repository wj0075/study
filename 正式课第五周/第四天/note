1.拖拽思路
1）基本效果
    1.当鼠标按下的时候：保存元素的位置和鼠标落脚点
    2.当鼠标移动的时候：元素以前的位置+新的鼠标落脚点-以前的鼠标落脚点
    3.当鼠标抬起的时候：释放元素身上的onmousemove和onmouseup事件
2）兼容处理：因为当快速移动的时候，元素会失去焦点，导致拖拽无法正常进行
    标准浏览器下：document
    IE浏览器下：焦点捕获
        - 设置焦点 ele.setCapture()
        - 释放焦点 ele.releaseCapture();
3）重复代码的封装：processThis ->功能：改变fn中的this指向，并且给fn中传event;
processThis:返回值 函数的定义阶段
2.DOM0级事件和DOM2级事件的区别：
DOM0级事件：1）属于元素的私有属性 2）只能发生在事件流的冒泡阶段 3）给同一个元素同一个行为绑定相同的方法，之前的方法就会被覆盖；
DOM2级事件：1）属于元素的公有属性，在元素的eventTarget这个类的原型上 2）控制发生在事件流的哪个阶段 3）同一个元素同一个行为上可以绑定多个不同的方法；
3.IE事件库的问题：
1）顺序问题 2）重复绑定的问题 3）this问题：attachEvent绑定方法中，this指向window；而不是当前发生事件的这个元素；
4.封装兼容版事件库思路：
    1）浏览器的兼容处理：
        - 标准浏览器：ele.addEventListener(type,fn,false)
        - IE浏览器：ele.attachEvent('on'+type,fn)
    2)标准浏览器下的DOM2级事件绑定：1）顺序 2）this指向当前元素 3）不会重复绑定
    IE下attachEvent存在的问题：1）顺序 2）this 3)重复绑定
    3）在IE浏览器下做兼容处理：
        -this：把fn放在匿名函数中-》无法解除事件绑定
               放在私有变量中-》unbind中无法获取该私有变量
               ele.tmp=匿名函数->同一个属性名上只能存一个值；后面绑定的方法，覆盖前面绑定方法；
               把每个tmp都放进自己事件池：[]; ele[type+'aEvent']=[];
        -重复绑定的问题： 在放进自己的事件池之前，先检查自己事件池中是否重复；如果重复，既不放进自己事件池（过滤），也不放入系统事件池；
        -顺序问题：把所有click行为下要绑定的方法，都放进自己事件池，给系统事件池中只放了一个run方法（获取数组，顺序调用-判断为函数才能顺序调用）；
        解除绑定的时候，一定不能用splice；而要赋值为null;
。。。。。。。。。。
作业：
    1.明早:事件库5个封装
    2.明天下午：
        1.回到顶部构造函数+jquery封装
        2.计算比例：放大镜






