1.正则：就是用来操作字符串（匹配和捕获）的一系列规则；
匹配：校验字符串是否符合我们的规则； 返回值-》布尔值 true false；
    匹配这里用的正则方法：test()   reg.test();
捕获：把复合我们规则的内容拎出来； 返回值-》复合规则的字符串；
2.正则有两种创建方式：
    1.字面量创建方式
    2.实例创建方式
3.字面量和实例创建的区别：
    1）字面量创建不能进行变量拼接，但是，实例创建可以进行变量拼接；
    2)字面量创建方式，特殊含义的字符不需要转移，但是，实例创建需要转义；
4.正则由两部分组成：元字符+修饰符；
元字符：就是放在两个斜杠之间的，不认识的代码；
元字符包含：1）代表特殊含义的元字符 2）代表次数的量词元字符；
1）代表特殊含义的元字符
    \ 转义
    | 或
    () 分组
    . 代表除了\n以外的其他字符；
    \n 换行
    \b 开头结尾和空格
    ^ 开头
    $ 结尾
    \s 空格    \d数字     \w 数字字母下划线
    \S 非空格  \D非数字    \W 非数字字母下划线
    [a-z] 字母 [^a-z]非字母
    [abc]abc三个字母中的任何一个 [^abc]除了这三个字母中的任何一个字符
2）代表次数的量词元字符；
    * 0到多
    + 1到多
    ? 0次或1次 可有可无的意思
    {n} 正好n次；
    {n,} n到多次
    {n,m} n次到m次
3)修饰符 g 全局  i 忽略大小写  m换行；

5.中括号总结：
1）中括号中的字符没有特殊含义；（但是像\w还是有特殊含义的）
2）中括号中，不会出现两位数；
6.关于小括号：
1）提高优先级:凡是有|出现的时候，外面一定要加上()来提高优先级； /^(18|19)$/
2）分组
3)只匹配不捕获 (?:)
7.正则的捕获：
1）exec：exec拿到的是个数组，一般情况下这个数组有三项：
    1.符合大正则的内容
    2.找到内容的索引
    3.原始字符串；
2）match：
3）replace：
8.正则捕获量大特性：
1）懒惰性：
    解决措施：全局g;
2)贪婪性：
    解决措施：在两次元字符后面加上?号；
9.正则的属性：lastIndex:代表开始查找位置的索引；
lastIndex主要受两方面的影响：1）exec 2）test；
10.问号的用法：
1）？ 量词元字符，代表可有可无
2）+？ 解决正则的贪婪性；
3）(?:) 只匹配不捕获；
11.exec和match区别：
1）在全局g的情况下，每次只能拿到一个数组，但是，exec可以把符合正则内容字符串进行小分组的摘取；
2）在全局g的情况下，match能拿到符合正则内容的字符串的数组；但他没有小分组
12.exec 可以封装match； 也是replace的实现原理；（replace中的arguments跟exec拿到的值是一模一样的）











